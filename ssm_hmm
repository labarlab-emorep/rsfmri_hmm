
# %% import required modules
# load the required modules
import pandas as pd
import glob
import matplotlib.pyplot as plt
# import numpy as np
from matplotlib.colors import LinearSegmentedColormap
from collections import defaultdict, Counter
import os
import numpy as np

import autograd.numpy as np
import autograd.numpy.random as npr
npr.seed(0)
import ssm
from ssm.util import find_permutation
from ssm.plots import gradient_cmap, white_to_color_cmap
import seaborn as sns
#import mysql.connector


# %% read in the CSV files; 
# %% old way reading the csv files 
# Directory path containing nested directories with CSV files
root_directory = '/mnt/keoki/experiments2/EmoRep/Exp2_Compute_Emotion/' + \
'data_scanner_BIDS/derivatives/classify_rest/'

# Pattern to match CSV files in nested directories
task='movies'

csv_pattern = f"{root_directory}/sub-*/ses-*/func/df_*{task}.csv"


# Retrieve all file paths matching the csv_patter using glob.glob
csv_files = glob.glob(csv_pattern)

# Initialize an empty list to store DataFrames
dfs = []

# Read each CSV file into a DataFrame and append it to the list
for file_path in csv_files:
    df = pd.read_csv(file_path,index_col=False)
    dfs.append(df)

# Combine all DataFrames into a single DataFrame
combined_df = pd.concat(dfs, ignore_index=True)

# Display or process the combined DataFrame as needed
print(combined_df.head())

# get the time series
data=combined_df.iloc[:,1:16]

# convert it into a numpy array
data=data.to_numpy()


# %% configure a color palette
sns.set_style("white")
sns.set_context("talk")

color_names = [
    'pink',
    'crimson',
    'tomato',
    'cyan',
    'lavender',
    'lime',
    'olive',
    'orange',
    'red',
    'maroon',
    'gold',
    'grey',
    'magenta',
    'blue',
    'purple'
]

colors = sns.xkcd_palette(color_names)
cmap = gradient_cmap(colors)

# Speficy whether or not to save figures
save_figures = True


# %% create a HMM 
# Set the parameters of the HMM
time_bins = 1200   # number of time bins
num_states = 15    # number of discrete states
obs_dim = 15       # dimensionality of observation

# %%


# %% plot the emotion score
# Plot the data and the smoothed data
lim = 1.05 * abs(data).max()
plt.figure(figsize=(18, 8))

for d in range(obs_dim):
    plt.plot(data[:,d] + lim * d,mfc=colors[d])

plt.xlim(0, time_bins*2)
plt.xlabel("Sample")
plt.yticks(lim * np.arange(obs_dim), ["$E_{}$".format(d+1) for d in range(obs_dim)])
plt.title("Emotion Scores at Rest first 5 participants")
plt.tight_layout()

#if save_figures:
#    plt.savefig("hmm_2.pdf")
# %% fit an HMM model to the observed time series
N_iters = 100
## testing the constrained transitions class
hmm = ssm.HMM(num_states, obs_dim, observations="gaussian")

hmm_lls = hmm.fit(data, method="em", num_iters=N_iters, init_method="kmeans")

plt.plot(hmm_lls, label="EM")
plt.xlabel("EM Iteration")
plt.ylabel("Log Probability")
plt.legend(loc="lower right")
plt.show()

most_likely_states = hmm.most_likely_states(data)

# %%
# Plot the observation distributions
obs=data
lim = .85 * abs(obs).max()
XX, YY = np.meshgrid(np.linspace(-lim, lim, 100), np.linspace(-lim, lim, 100))
data1 = np.column_stack((XX.ravel(), YY.ravel()))
input = np.zeros((data1.shape[0], 0))
mask = np.ones_like(data1, dtype=bool)
tag = None
lls = hmm.observations.log_likelihoods(data1, input, mask, tag)

plt.figure(figsize=(6, 6))
for k in range(num_states):
    plt.contour(XX, YY, np.exp(lls[:,k]).reshape(XX.shape), cmap=white_to_color_cmap(colors[k]))
    plt.plot(obs[most_likely_states==k, 0], obs[most_likely_states==k, 1], 'o', mfc=colors[k], mec='none', ms=4)
    
plt.plot(obs[:,0], obs[:,1], '-k', lw=1, alpha=.25)
plt.xlabel("$x_1$")
plt.ylabel("$x_2$")
plt.title("Observation Distributions")


# %%

# %% emotional state distribution from inferred sequence
#emo_sequence = combined_df['label_max']
emo_sequence = most_likely_states

#print(emo_sequence.head())

# Create a mapping from string values to numerical categories
categories = {val: idx for idx, val in enumerate(sorted(set(emo_sequence)))}

# Convert string values to numerical categories
numerical_emo_sequence = np.array([categories[val] for val in emo_sequence])

# Get unique numerical categories and their counts
unique_categories, counts = np.unique(numerical_emo_sequence, return_counts=True)

colors= [
    'pink',
    'crimson',
    'tomato',
    'cyan',
    'lavender',
    'lime',
    'olive',
    'orange',
    'red',
    'maroon',
    'gold',
    'grey',
    'magenta',
    'blue',
    'purple'
][:len(unique_categories)]

# Plotting a histogram for each category with different colors
plt.figure(figsize=(24, 16))
for category, count, color in zip(unique_categories, counts, colors):
    plt.bar(category, count, color=color, label=list(categories.keys())[list(categories.values()).index(category)])

# Customize the plot labels and title
plt.xlabel('Emotion',fontsize=35)
plt.ylabel('Frequency',fontsize=35)
plt.title('Distribution of Emotional States at Rest ("Observed")',fontsize=40,pad=20)

#plt.title('Distribution of Emotional States at Rest(Inferred))',fontsize=40,pad=20)

plt.xticks(unique_categories,[list(categories.keys())[list(categories.values()).index(cat)] for cat in unique_categories], 
           fontsize=35,rotation=90)
plt.yticks(fontsize=35)
plt.tight_layout
#plt.legend(fontsize=15)
plt.show()


# %% TPM from inferred emotional states
# Create a dictionary to map unique states to integers
import numpy as np

states = sorted(set(emo_sequence))
state_indices = {state: idx for idx, state in enumerate(states)}

# Convert sequence of string states to a sequence of integer indices
indices_sequence = [state_indices[state] for state in emo_sequence]

# Calculate transition matrix from the sequence of states
num_states = len(states)
transition_matrix = np.zeros((num_states, num_states))

for i in range(len(indices_sequence) - 1):
    current_state = indices_sequence[i]
    next_state = indices_sequence[i + 1]
    transition_matrix[current_state][next_state] += 1

# Normalize transition matrix to obtain transition probabilities
transition_matrix /= transition_matrix.sum(axis=1, keepdims=True)

# Create a mask to threshold transition probabilities
threshold = 0.05
masked_matrix = np.ma.masked_where(transition_matrix < threshold, transition_matrix)

# Define a colormap for values above the threshold
cmap = plt.cm.plasma
tpm_colors = cmap(np.arange(cmap.N))
tpm_colors[0] = (1, 1, 1, 0.0)  # Set color for values below the threshold (transparent white)

new_cmap = LinearSegmentedColormap.from_list('truncated_cmap', tpm_colors)

# Visualize the thresholded transition probability matrix
plt.figure(figsize=(24, 16))
plt.imshow(masked_matrix, cmap=new_cmap, interpolation='nearest')
cbar = plt.colorbar()
cbar.set_label('Transition Probability', fontsize=30)
cbar.ax.tick_params(labelsize=25)

plt.title('Transition Probability Matrix (Inferred)',fontsize=40)
plt.xlabel('Next State',fontsize=35)
plt.ylabel('Current State',fontsize=35)
plt.xticks(np.arange(num_states), states,fontsize=35,rotation=90)
plt.yticks(np.arange(num_states), states,fontsize=35)
plt.tight_layout()
plt.show()

# %% visualize state duration 
true_state_list, true_durations = ssm.util.rle(emo_sequence)
inferred_state_list, inferred_durations = ssm.util.rle(most_likely_states)

# Rearrange the lists of durations to be a nested list where
# the nth inner list is a list of durations for state n
true_durs_stacked = []
inf_durs_stacked = []
for s in range(num_states):
    true_durs_stacked.append(true_durations[true_state_list == s])
    inf_durs_stacked.append(inferred_durations[inferred_state_list == s])
    
fig = plt.figure(figsize=(8, 4))
plt.hist(true_durs_stacked, label=['state ' + str(s) for s in range(num_states)])
plt.xlabel('Duration')
plt.ylabel('Frequency')
#plt.legend()
plt.title('Histogram of Observed State Durations')

fig = plt.figure(figsize=(8, 4))
plt.hist(inf_durs_stacked, label=['state ' + str(s) for s in range(num_states)])
plt.xlabel('Duration')
plt.ylabel('Frequency')
#plt.legend()
plt.title('Histogram of Inferred State Durations')

plt.show()

# %%

transition_matrix=np.zeros((15,15))
true_transition_mat = transition_matrix
learned_transition_mat = hmm.transitions.transition_matrix

fig = plt.figure(figsize=(8, 4))
plt.subplot(121)
im = plt.imshow(true_transition_mat, cmap='gray')
plt.title("Transition Matrix(Observed)")

plt.subplot(122)
im = plt.imshow(learned_transition_mat, cmap='gray')
plt.title("Transition Matrix (Inferred)")

cbar_ax = fig.add_axes([0.95, 0.15, 0.05, 0.7])
fig.colorbar(im, cax=cbar_ax)
plt.show()
# %%
